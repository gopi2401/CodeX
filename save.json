{"schema_version":1,"items":[{"name":"My Notes","id":"58599244-40c8-4bbf-8732-b33f06d20c3a","color":"#000000","icon":"book-2","children":[{"name":"Example Note","id":"59924440-c88b-4f87-b2b3-3f06d20c3a1b","color":"#999999","icon":"file-text","fileName":"Example-Note59924440-c88b-4f","textContent":"Date End\n\nFix: Ensure Early Bird Ends on March 10, 2025\n\nYou need to compare the dateNow with March 10, 2025, 23:59:59, not March 11, 2025.\n\nFixed Code:\n\nconst Early_Bird_Last_Date = new Date(2025, 2, 10); // March 10, 2025 \nEarly_Bird_Last_Date.setHours(23, 59, 59, 999); // Set end of day for March 10 \nconst dateNow = new Date(); \nconst isEarlyBird = dateNow <= Early_Bird_Last_Date; // Ensure today is within Early Bird period console.log(Early_Bird_Last_Date, isEarlyBird);\n\nWhy This Works?\n\nNow, Early_Bird_Last_Date is March 10, 2025, 23:59:59, meaning the early bird period ends at the end of that day.\n\nIf dateNow is March 11, 2025, 00:00:00 or later, isEarlyBird will return false.\n\nIf dateNow is March 10, 2025, 23:59:59 or earlier, isEarlyBird will return true.\n\nExample Output:\n\nCase 1: If Today is March 10, 2025, 10:00 AM\n\nMon Mar 10 2025 23:59:59 GMT+0000 (UTC) true\n\n‚úÖ Early Bird is still active.\n\nCase 2: If Today is March 11, 2025, 12:00 AM\n\nMon Mar 10 2025 23:59:59 GMT+0000 (UTC) false\n\n‚ùå Early Bird has ended.\n\nThis should now work exactly as expected! üöÄ Let me know if you need further clarifications.\n\n\nLogin page navber hide\n\nimport { Routes, Route, useLocation } from \"react-router-dom\";\n\nfunction App() {\n  const location = useLocation();\n  const paths = [\"/Login\", \"/Dashboard\"];\n  const isLayout = paths.includes(location.pathname);\n  return (\n    <>\n      {!isLayout && <NavBar />}\n\nCountdownTimer widget\n\nimport React, { useEffect } from \"react\";\n\nconst CountdownTimer = () => {\n  useEffect(() => {\n    const script = document.createElement(\"script\");\n    script.src = \"https://cdn.logwork.com/widget/countdown.js\";\n    script.async = true;\n    document.body.appendChild(script);\n\n    return () => {\n      console.log(\"Check\");\n    };\n  }, []);\n  return (\n    <div className=\"bg-white rounded-xl max-w-xl shadow-md\">\n      <a\n        href=\"https://logwork.com/countdown-5usd\"\n        class=\"countdown-timer\"\n        data-timezone=\"Asia/Kolkata\"\n        data-textcolor=\"#000000\"\n        data-date=\"2025-03-21 10:09\"\n        data-digitscolor=\"#ffffff\"\n      >\n        Countdown Timer\n      </a>\n    </div>\n  );\n};\n\nexport default CountdownTimer;\n\n\n1. Buffer Objects in MongoDB\n\nBuffer objects are typically used to store binary data directly within documents as fields.\n\nPros:\n\n‚úÖ Simplicity: Easy to implement and directly embed binary data within a document.\n\n‚úÖ Faster Retrieval: Fetching a single document with binary data is quick.\n\n‚úÖ Good for Small Files: Suitable for small binary data, such as profile pictures or small images.\n\n‚úÖ Atomic Operations: Since the data is embedded within a single document, it can be updated and retrieved atomically.\n\nCons:\n\n‚ùå Size Limitations: MongoDB documents are limited to 16 MB, making Buffers unsuitable for large files.\n\n‚ùå Memory Consumption: Fetching a large number of documents with embedded binary data can consume significant memory.\n\n‚ùå Performance Issues: Storing many binary files directly in MongoDB can slow down queries and increase I/O operations.\n\n2. GridFS (MongoDB's File Storage System)\n\nGridFS splits large files into smaller chunks and stores them in two collections: fs.files and fs.chunks.\n\nPros:\n\n‚úÖ Handles Large Files: Can store files larger than 16 MB, making it suitable for videos, PDFs, or large images.\n\n‚úÖ Efficient Retrieval: Supports streaming large files in chunks, which reduces memory consumption.\n\n‚úÖ Metadata Support: Allows you to store additional metadata with each file.\n\n‚úÖ Built-in Support: Directly supported by MongoDB and has drivers for most programming languages.\n\nCons:\n\n‚ùå Complexity: More complex to set up and manage compared to using simple Buffers.\n\n‚ùå Slower for Small Files: Not as efficient for small binary data compared to embedding directly.\n\n‚ùå Additional Queries: Requires multiple queries to gather all file chunks, which might slightly impact performance for very small files.\n\nWhen to Use What?\n\nScenario\n\nUse Buffer\n\nUse GridFS\n\nSmall binary files (e.g., images)\n\n‚úÖ\n\n‚ùå\n\nLarge files (videos, PDFs)\n\n‚ùå\n\n‚úÖ\n\nFrequent file updates\n\n‚úÖ\n\n‚ùå (chunks can complicate updates)\n\nStreaming large files\n\n‚ùå\n\n‚úÖ\n\nSimple setup and quick access\n\n‚úÖ\n\n‚ùå\n\nSummary\n\nUse Buffer when:\n\nFiles are small and easily fit within MongoDB‚Äôs document size limit.\n\nYou need simplicity and quick retrieval.\n\nUse GridFS when:\n\nYou need to store large files (more than 16 MB).\n\nYou want efficient file streaming and metadata support.","favorited":false}],"opened":true}]}